% a) Enestrom-Kakeya Theorem
% Sarah Garrow during office hours accidentally plotted a wrong transfer
% function, resulting in rediscovering Enestrom-Kakeya Theorem, see 
% http://www.math.vanderbilt.edu/~esaff/texts/39.pdf Theorem B for details 

% b) Kakeya set: A subset in R^n contains a unit line segment in every
% direction, and the line segment can rotate within this set full 2*pi
% radians in every direction. Such a set is called Kakeya set. A deltoid is
% a preliminary solution to the problem proposed by Kakeya in 1917 that 
% whether or not Kakeya set has a min area. Modern version of this problem
% considering the area in the sense of measure theory is called Kakeya
% Conjecture; it is still an open problem for dimension n>=3.

% Here we just reproduced the deltoid illustrated on the Wikipedia.org 
% https://en.wikipedia.org/wiki/Deltoid_curve

% 2016-09-26
% Y\"un Han
% ECE 486 Lab 3

%% 
clear % clear values of variables in workspace
clc % clear messages in the command window
clf % clear existing figures 
close all % close all existing windows; w/o 'all', only close the latest

%% Accidentally rediscovered Kakeya Theorem

% What Sarah Garrow originally wanted was to plot an array of 2nd order 
% transfer functions with varying damping ratios, using the following matlab
% code

% **** the following code is wrong for the purpose above **** 
% generate an array for the coefficient of s-term in the 2nd order TF,
% hence varying the damping ratio in the 2nd order TF
n = linspace(1,5,100); 

num = 1517; % a random numerator, which does not matter since we want poles
den = [1 n 1200]; % expect that den would be an array of 2nd order polynomials
% den = [1 n 10]; % we also tested this one, see the explanation below for
% the choice of 10 for the constant term

sys2ndTF = tf(num,den); % expecting that sys2ndTF would be an array of TFs
figure(1)
pzmap(sys2ndTF) % plot the poles of the 2nd TF with varying damping ratio
axis equal

% see the figure generated by the above code. Instead of getting poles of
% an array of 2nd order TFs, matlab plotted poles of a **single** TF with many
% many poles. (In this case, 102 poles of a 102nd order TF.)

% **** why the above code has failed ****
% matlab command tf did not generate an array of TFs in line 39/40; instead
% matlab saw that n variable in the middle as an array and expanded the
% array in array operation in line 39, we ended up with a 102nd order TF
% once line 39 has been executed. To fulfil Sarah's original purpose, we
% wrote a loop such that we could sweep all possible n's defined in line
% 36.

% Interestingly, the plot was not what we needed nevertheless it gave
% us an almost perfect circle. Why? Note that by line 39/40, we created a 
% polynomial with **increasing** coefficients. Theorem A (see the link above) 
% tells us that the poles would not be in the unit disc, but Theorem B gives 
% sharper estimates of the location, it bounds the poles with an annulus. 
% In our example, if we look at the ratio of adjacent coefficients, it is 
% almost 1 (except the last one). So the poles are forced into an annulus 
% close to the boundary of the disc (poles are outside the unit disc though), 
% which is a unit circle.

%% Deltoid plot
% Derivation of the deltoid parametric equation. Suppose the larger circle
% has radius b and smaller one radius a. Note that the centre of the
% rolling circle is on a circle with radius (b-a), concentric with the
% larger one. Connect the centres of both the larger circle and the
% smaller with a line, starting from the centre of the larger circle, pointing
% to the centre of the rolling circle. Then this line can also be regarded as 
% the vector corresponding to the centre of the smaller circle on a complex
% plane. When this vector rotates an angle theta_b, a point on the smaller circle 
% travels a distance of b*theta_b. (length of arc sector, when there is no 
% slipping/sliding between the two circles.) Writing this length of arc 
% sector in terms of how much the smaller circle has rotated, 
% b*theta_b = a*theta_a. Another vector starting from the centre of the
% rolling circle, pointing to a fixed point on the rolling circle is given
% by 

% a*exp(i*(theta_a-theta_b)). 

% By vector addition, the complex number associated with the fixed point on
% the rolling circle is given by 

% (b-a)*exp(i*theta_b) + a*exp(i*(theta_a - theta_b)).

% Plugging in theta_a = b/a*theta_b, we have

% (b-a)*exp(i*theta_b) + a*exp(i*(b-a)/a*theta_b)),

% which is the form given in complex coordinates on Wikipedia.

% clear
% clc
% clf
% close all

% vary theta_b = 0 to 2*pi, generate an animation like the one on Wikipedia.
b = 3;
a = 1; % b/a = 3, a deltoid is a special case of hypocycloid, try also a = .5 etc
dt = 0.01; % control the precision
theta_b = 0:dt:2*pi;

% plot the larger circle
largeCircleFig = figure('name','Parametric Deltoid','numbertitle','off');
% polar form
plot(b*cos(theta_b),b*sin(theta_b),'b','linewidth',2.5)
% hold on
% axis([-3.1 3.1 -3.1 3.1])
axis equal
grid(gca,'on') % same as grid on
title('A Deltoid Curve')
xlabel('x')
ylabel('y')

% mark the start point of the deltoid
% deltoid0 = line('xdata',b*cos(theta_b(1)),'ydata',b*sin(theta_b(1)), ...
%                 'color', 'r', 'marker', 'o', 'markersize',5,'linewidth',3);

% mark the rolling circle   
xcenterRollingCircle = (b-a)*cos(theta_b(1));
ycenterRollingCircle = (b-a)*sin(theta_b(1));
    
rollingCircle = line('xdata',a*cos(theta_b)+xcenterRollingCircle, ...
                     'ydata',a*sin(theta_b)+ycenterRollingCircle, ...
                     'color','k','markersize',2.5); % low level usage of 'line'
centerRollingCircle = line('xdata',(b-a), ...
                           'ydata',0,...
                           'color','k','marker','o','markersize',5);
lineCenter2Edge = line('xdata',[],'ydata',[]); % init new line handle

% init struct array for movie frames returned by getframe, see output
% arguments of 'getframe'
movFrame(numel(theta_b)) = struct('cdata',[],'colormap',[]); 
% init image frame to save images to GIF
imgFrame=cell(numel(theta_b),1);

for i = 1:numel(theta_b)    
    
    xdata = (b-a)*cos(theta_b(i))+a*cos((b-a)/a*theta_b(i)); % deltoid data
    ydata = (b-a)*sin(theta_b(i))-a*sin((b-a)/a*theta_b(i)); 
    xdataCenter = (b-a)*cos(theta_b(i)); % centre data of rolling circle
    ydataCenter = (b-a)*sin(theta_b(i));
    % roll the rolling circle
    set(rollingCircle, ...
        'xdata',a*cos(theta_b)+xdataCenter, ...
        'ydata',a*sin(theta_b)+ydataCenter, ...
        'color','k','markersize',2.5,'linewidth',2.5);
    set(centerRollingCircle, ...
        'xdata',xdataCenter, ...
        'ydata',ydataCenter, ...
        'color','k','marker','o','markersize',2,'linewidth',2.5)
    
    % compute real time lineCenter2Edge data, stored in dummy points (t,y)
    if (xdataCenter<xdata) % later xdataCenter will be greater than xdata
        t = xdataCenter:dt:xdata; 
    else 
        t = xdata:dt:xdataCenter;
    end
    % get the line
    coeff = polyfit([xdata xdataCenter],[ydata ydataCenter],1);
    y = coeff(1)*t + coeff(2);

    % draw the line from centre of the rolling circle to the fixed point on
    % the edge
    set(lineCenter2Edge, ...
        'xdata',t, ...
        'ydata',y, ...
        'color','k','linewidth',1.5);
    
    % trajectory of a fixed point on the rolling circle
    line('xdata',xdata, ...
         'ydata',ydata, ...
         'color','r','marker','o','markersize',2.5,'linewidth',2.5)
    
    % axis([-3.1 3.1 -3.1 3.1]) 
    % set(gca,'xlim',[-3.1 3.1],'ylim',[-3.1 3.1]) % the same as above
    % axis equal
    
    movFrame(i) = getframe(gcf);
    
    imgFrame{i} = frame2im(movFrame(i));
       
end

% show the movie centred at deltoid figure handle
playNTimes = 3;
playFPS = 80;
movie(largeCircleFig,movFrame,playNTimes,playFPS) % play the movie 3 time(s) at 80fps
% note: movie will play the movie during matlab session, not saving
% anything.

%% save images to GIF
% see details at https://www.mathworks.com/help/matlab/ref/imwrite.html
filename = 'deltoidCurve.gif'; % Specify the output file name
for idx = 1:numel(theta_b)
    [A,map] = rgb2ind(imgFrame{idx},256);
    if idx == 1
        % delay time 0.0125s = 80FPS
        imwrite(A,map,filename,'gif','LoopCount',Inf,'DelayTime',.0125); 
    else
        imwrite(A,map,filename,'gif','WriteMode','append','DelayTime',.0125);
    end
end 
